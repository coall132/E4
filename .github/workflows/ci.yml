name: ci

on:
  push:
    branches: [ main ]
  pull_request:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  tests-api:
    runs-on: ubuntu-latest
    permissions: { contents: read }
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with: { python-version: "3.11" }

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-api-${{ runner.os }}-${{ hashFiles('API/requirements_dev.txt') }}

      - name: Install dev deps (API)
        working-directory: API
        run: pip install -r requirements_dev.txt

      - name: Run tests (API)
        working-directory: API
        env:
          TURNSTILE_DEV_BYPASS: "1"
          DISABLE_WARMUP: "1"
          API_STATIC_KEY: ${{ secrets.API_STATIC_KEY }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          PYTHONPATH: ${{ github.workspace }}
        run: pytest -q

  tests-front:
    needs: tests-api
    runs-on: ubuntu-latest
    permissions: { contents: read }
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_DB: app
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        ports: [ "5432:5432" ]
        options: >-
          --health-cmd="pg_isready -U postgres -d app"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=20
      redis:
        image: redis:7
        ports: [ "6379:6379" ]
        options: >-
          --health-cmd="redis-cli ping || exit 1"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=20

    env:
      BASE_URL: http://127.0.0.1:8000
      DATABASE_URL: postgresql+psycopg2://postgres:postgres@localhost:5432/app
      DB_HOST: localhost
      DB_PORT: "5432"
      DB_NAME: app
      DB_USER: postgres
      DB_PASSWORD: postgres

      POSTGRES_DB: app
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      REDIS_URL: redis://localhost:6379/0
      TURNSTILE_DEV_BYPASS: "1"
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
      API_STATIC_KEY: ${{ secrets.API_STATIC_KEY }}
      DISABLE_WARMUP: "0"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # --- Python pour lancer FastAPI & seed DB ---
      - name: Setup Python
        uses: actions/setup-python@v5
        with: { python-version: "3.11" }

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-e2e-${{ runner.os }}-${{ hashFiles('API/requirements_dev.txt') }}

      - name: Install API deps
        working-directory: API
        run: pip install -r requirements_dev.txt
      
      - name: Seed database (schemas + 1 restaurant)
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
        run: |
          python - <<'PY'
          import os
          os.environ['DATABASE_URL'] = os.getenv('DATABASE_URL', '')
          from sqlalchemy.sql import text
          from API.database import engine, SessionLocal
          from API import models, CRUD

          # Schémas + tables
          with engine.begin() as conn:
              conn.execute(text('CREATE SCHEMA IF NOT EXISTS "ml"'))
              conn.execute(text('CREATE SCHEMA IF NOT EXISTS "user_base"'))
          models.Base.metadata.create_all(bind=engine, checkfirst=True)

          db = SessionLocal()
          try:
              # 1) Restaurant
              if not db.query(models.Etablissement).first():
                  e = models.Etablissement(
                      id_etab=1, nom='Test Trattoria', adresse='1 rue A, Tours',
                      rating=4.2, priceLevel='2', latitude=47.39, longitude=0.69,
                      websiteUri='https://example.test', description='Italien cosy'
                  )
                  db.add(e); db.flush()
                  db.add(models.Options(id_etab=e.id_etab, reservable=True, outdoorSeating=True))
                  db.add_all([
                      models.OpeningPeriod(id_etab=e.id_etab, open_day=1, open_hour=11, open_minute=30, close_day=1, close_hour=22, close_minute=0),
                      models.OpeningPeriod(id_etab=e.id_etab, open_day=6, open_hour=11, open_minute=30, close_day=6, close_hour=23, close_minute=0),
                  ])
                  db.commit()

              # 2) Utilisateur e2e
              user = db.query(models.User).filter(models.User.username=='e2e').first()
              if not user:
                  user = models.User(
                      email='e2e@e2e.test',
                      username='e2e',
                      hashed_password=CRUD.ph.hash('pass1234!')   # même algo que ton API
                  )
                  db.add(user)
                  db.flush()  # récupère user.id

              # 3) Form + Prediction (si aucune pour cet utilisateur)
              has_pred = db.query(models.Prediction).filter(models.Prediction.user_id==user.id).first()
              if not has_pred:
                  form = models.FormDB(
                      price_level=2,
                      city='Tours',
                      open='soir_weekend',
                      options=['reservable','outdoorSeating'],
                      description='italien terrasse'
                  )
                  db.add(form); db.flush()

                  pred = models.Prediction(
                      form_id=form.id,
                      user_id=user.id,
                      k=3,
                      model_version='ci',
                      latency_ms=100,
                      status='ok',
                  )
                  db.add(pred); db.flush()

                  db.add(models.PredictionItem(
                      prediction_id=pred.id,
                      rank=1,
                      etab_id=1,
                      score=0.987
                  ))
                  db.commit()

              print('Seed OK')
          finally:
              db.close()
          PY

      - name: Start API (background)
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          REDIS_URL: ${{ env.REDIS_URL }}
          TURNSTILE_DEV_BYPASS: "1"
          DISABLE_WARMUP: "0"
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          API_STATIC_KEY: ${{ secrets.API_STATIC_KEY }}
          PYTHONPATH: ${{ github.workspace }}
        run: |
          nohup python -m uvicorn API.main:app --host 0.0.0.0 --port 8000 > api.log 2>&1 &

      - name: Wait for API to be up
        run: |
          for i in {1..60}; do
            if curl -fsS $BASE_URL/login >/dev/null; then
              echo "API is up"; exit 0
            fi
            echo "waiting API..."; sleep 2
          done
          echo "::error::API did not start in time"
          echo "---- api.log ----"
          cat api.log || true
          exit 1

      # --- Node + Playwright ---
      - name: Setup Node
        uses: actions/setup-node@v4
        with: { node-version: "20" }

      - name: Cache npm
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: npm-${{ runner.os }}-${{ hashFiles('package-lock.json') }}
          restore-keys: npm-${{ runner.os }}-

      - name: Install Playwright (no project scaffolding)
        run: |
          npm init -y
          npm i -D @playwright/test
          npx playwright install --with-deps

      - name: Run Playwright tests
        env:
          BASE_URL: ${{ env.BASE_URL }}
          TURNSTILE_DEV_BYPASS: "1"
        run: npx playwright test --reporter=html,line

      - name: Upload Playwright HTML report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
          if-no-files-found: ignore

  build-and-push:
    needs: [tests-api, tests-e2e]
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # ---------- API ----------
      - name: Build & push API image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./API/Dockerfile
          target: prod
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/restaurant-api2:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/restaurant-api2:${{ github.sha }}
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/restaurant-api2:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/restaurant-api2:buildcache,mode=max

      # ---------- MLflow ----------
      - name: Build & push MLflow image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./mlflow.Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/restaurant-mlflow2:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/restaurant-mlflow2:${{ github.sha }}
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/restaurant-mlflow2:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/restaurant-mlflow2:buildcache,mode=max

      # ---------- Monitor ----------
      - name: Build & push Monitor image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./monitor.Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/restaurant-monitor2:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/restaurant-monitor2:${{ github.sha }}
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/restaurant-monitor2:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/restaurant-monitor2:buildcache,mode=max

      # ---------- Redis ----------
      - name: Build & push Redis image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./redis.Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/restaurant-redis:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/restaurant-redis:${{ github.sha }}
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/restaurant-redis:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/restaurant-redis:buildcache,mode=max

      # ---------- Fail2ban ----------
      - name: Build & push Fail2ban image
        uses: docker/build-push-action@v6
        with:
          context: ./fail2ban
          file: ./fail2ban/fail2ban.Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/restaurant-fail2ban:latest
            ${{ secrets.DOCKERHUB_USERNAME }}/restaurant-fail2ban:${{ github.sha }}
          cache-from: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/restaurant-fail2ban:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/restaurant-fail2ban:buildcache,mode=max

  deploy-local:
    needs: build-and-push
    runs-on: [self-hosted, local, windows]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Sync compose to deploy folder (cmd)
        shell: cmd
        run: |
          if not exist "%USERPROFILE%\app-e4" mkdir "%USERPROFILE%\app-e4"
          copy /Y "%GITHUB_WORKSPACE%\docker-compose.yml" "%USERPROFILE%\app\docker-compose.yml"

      - name: Déployer localement (pull & up)
        env:
          IMAGE_TAG: ${{ github.sha }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        shell: cmd
        run: |
          cd /d "%USERPROFILE%\app-e4"
          echo %DOCKERHUB_TOKEN% | docker login -u %DOCKERHUB_USERNAME% --password-stdin 
          for /f "tokens=*" %%i in ('docker network ls --format "{{.Name}}" ^| findstr /r "^data_network$"') do set found=1
          if not defined found docker network create data_network
          docker compose --env-file .env pull
          docker compose --env-file .env up -d
          docker image prune -f
          docker compose ps
